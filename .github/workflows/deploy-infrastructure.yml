name: üöÄ Deploy Infrastructure

on:
  push:
    branches: [main, production]
    paths:
      - '**.tf'
      - '**.tfvars'
      - 'website/**'
      - '.github/workflows/deploy-infrastructure.yml'
  pull_request:
    branches: [main, production]
    paths:
      - '**.tf'
      - '**.tfvars'
  workflow_dispatch:
    inputs:
      action:
        description: 'Action to perform'
        required: true
        default: 'apply'
        type: choice
        options:
          - plan
          - apply

env:
  TF_VERSION: '1.5.0'
  AWS_REGION: 'us-east-1'
  TF_IN_AUTOMATION: true
  TF_INPUT: false

permissions:
  contents: read
  pull-requests: write
  security-events: write

jobs:
  setup:
    name: üîç Detect Project Structure
    runs-on: ubuntu-latest
    outputs:
      tf_dir: ${{ steps.detect.outputs.tf_dir }}
    
    steps:
      - name: üì• Checkout Code
        uses: actions/checkout@v4

      - name: üîç Detect Terraform Directory
        id: detect
        run: |
          echo "üîç Detecting Terraform files location..."
          
          if [ -f "main.tf" ]; then
            echo "‚úÖ Found Terraform files in root directory"
            echo "tf_dir=." >> $GITHUB_OUTPUT
          elif [ -f "terraform/main.tf" ]; then
            echo "‚úÖ Found Terraform files in terraform/ subdirectory"
            echo "tf_dir=./terraform" >> $GITHUB_OUTPUT
          else
            echo "‚ùå ERROR: Cannot find main.tf in root or terraform/ directory"
            exit 1
          fi

  validate:
    name: üîç Validate Terraform
    runs-on: ubuntu-latest
    needs: setup
    
    steps:
      - name: üì• Checkout Code
        uses: actions/checkout@v4

      - name: üîß Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: üé® Terraform Format Check
        id: fmt
        working-directory: ${{ needs.setup.outputs.tf_dir }}
        run: terraform fmt -check -recursive
        continue-on-error: true

      - name: üîß Terraform Init
        working-directory: ${{ needs.setup.outputs.tf_dir }}
        run: terraform init -backend=false

      - name: ‚úÖ Terraform Validate
        id: validate
        working-directory: ${{ needs.setup.outputs.tf_dir }}
        run: terraform validate

      - name: üìä Comment PR - Validation
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        continue-on-error: true
        with:
          script: |
            const output = `
            ## üîç Terraform Validation Results
            
            | Check | Result |
            |-------|--------|
            | Format | ${{ steps.fmt.outcome == 'success' && '‚úÖ Passed' || '‚ö†Ô∏è Check needed' }} |
            | Validate | ${{ steps.validate.outcome == 'success' && '‚úÖ Passed' || '‚ùå Failed' }} |
            `;
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: output
            });

  security-scan:
    name: üîí Security Scan
    runs-on: ubuntu-latest
    needs: [setup, validate]
    
    steps:
      - name: üì• Checkout Code
        uses: actions/checkout@v4

      - name: üîç Run Checkov
        uses: bridgecrewio/checkov-action@master
        with:
          directory: ${{ needs.setup.outputs.tf_dir }}
          framework: terraform
          soft_fail: true
        continue-on-error: true

  plan:
    name: üìã Terraform Plan
    runs-on: ubuntu-latest
    needs: [setup, validate, security-scan]
    if: github.event_name == 'pull_request' || (github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'plan')
    
    steps:
      - name: üì• Checkout Code
        uses: actions/checkout@v4

      - name: üîß Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          terraform_wrapper: false

      - name: üîê Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: üìÇ Create terraform.tfvars
        working-directory: ${{ needs.setup.outputs.tf_dir }}
        run: |
          if [ ! -f terraform.tfvars ]; then
            if [ -f terraform.tfvars.example ]; then
              cp terraform.tfvars.example terraform.tfvars
            else
              cat > terraform.tfvars << 'EOF'
          use_custom_domain = false
          domain_name       = ""
          project_name      = "secure-website"
          environment       = "production"
          allowed_countries = ["US", "CA", "GB"]
          EOF
            fi
          fi

      - name: üîß Terraform Init
        working-directory: ${{ needs.setup.outputs.tf_dir }}
        run: terraform init

      - name: üß† Smart Resource Import
        working-directory: ${{ needs.setup.outputs.tf_dir }}
        run: |
          echo "üß† Checking for existing AWS resources..."
          
          # Get project config
          PROJECT=$(terraform console <<< "var.project_name" 2>/dev/null | tr -d '"' || echo "secure-website")
          ENV=$(terraform console <<< "var.environment" 2>/dev/null | tr -d '"' || echo "production")
          PREFIX="${PROJECT}-${ENV}"
          
          echo "üìã Project: $PROJECT | Environment: $ENV"
          
          # Smart import function
          smart_import() {
            local tf_resource=$1
            local aws_identifier=$2
            local resource_name=$3
            
            # Check if already in state
            if terraform state show "$tf_resource" &>/dev/null; then
              echo "  ‚úÖ $resource_name already managed"
              return 0
            fi
            
            # Try to import
            echo "  üîÑ Importing $resource_name..."
            if terraform import "$tf_resource" "$aws_identifier" 2>&1 | tee /tmp/import.log; then
              echo "  ‚úÖ Successfully imported $resource_name"
              return 0
            else
              if grep -q "Cannot import non-existent" /tmp/import.log; then
                echo "  ‚ÑπÔ∏è  $resource_name doesn't exist yet (will be created)"
              else
                echo "  ‚ö†Ô∏è  Import attempted for $resource_name"
              fi
              return 1
            fi
          }
          
          echo ""
          echo "üîç Scanning AWS for existing resources..."
          echo ""
          
          # Import S3 Buckets
          echo "üì¶ S3 Buckets:"
          smart_import "aws_s3_bucket.website" "${PREFIX}-website" "Website Bucket"
          smart_import "aws_s3_bucket.logs" "${PREFIX}-logs" "Logs Bucket"
          
          # Import WAF Web ACL
          echo ""
          echo "üõ°Ô∏è  WAF Web ACL:"
          WAF_LIST=$(aws wafv2 list-web-acls --scope CLOUDFRONT --region us-east-1 --output json 2>/dev/null || echo '{"WebACLs":[]}')
          WAF_ID=$(echo "$WAF_LIST" | jq -r ".WebACLs[] | select(.Name==\"${PREFIX}-waf\") | .Id" || echo "")
          WAF_NAME=$(echo "$WAF_LIST" | jq -r ".WebACLs[] | select(.Name==\"${PREFIX}-waf\") | .Name" || echo "")
          
          if [ -n "$WAF_ID" ] && [ "$WAF_ID" != "null" ]; then
            WAF_IMPORT_ID="${WAF_ID}/${WAF_NAME}/CLOUDFRONT"
            smart_import "aws_wafv2_web_acl.main" "$WAF_IMPORT_ID" "WAF Web ACL"
          else
            echo "  ‚ÑπÔ∏è  No existing WAF found (will be created)"
          fi
          
          # Import CloudFront Distribution
          echo ""
          echo "‚òÅÔ∏è  CloudFront Distribution:"
          DIST_LIST=$(aws cloudfront list-distributions --output json 2>/dev/null || echo '{"DistributionList":{"Items":[]}}')
          DIST_ID=$(echo "$DIST_LIST" | jq -r ".DistributionList.Items[] | select(.Comment==\"${PREFIX} distribution\") | .Id" || echo "")
          
          if [ -n "$DIST_ID" ] && [ "$DIST_ID" != "null" ]; then
            smart_import "aws_cloudfront_distribution.main" "$DIST_ID" "CloudFront Distribution"
            smart_import "aws_cloudfront_origin_access_control.main" "$(aws cloudfront list-origin-access-controls --query 'OriginAccessControlList.Items[0].Id' --output text 2>/dev/null || echo '')" "Origin Access Control" || true
          else
            echo "  ‚ÑπÔ∏è  No existing CloudFront distribution found (will be created)"
          fi
          
          # Import CloudWatch Dashboard
          echo ""
          echo "üìä CloudWatch Dashboard:"
          if aws cloudwatch get-dashboard --dashboard-name "${PREFIX}-dashboard" --region us-east-1 &>/dev/null; then
            smart_import "aws_cloudwatch_dashboard.main" "${PREFIX}-dashboard" "CloudWatch Dashboard"
          else
            echo "  ‚ÑπÔ∏è  No existing dashboard found (will be created)"
          fi
          
          echo ""
          echo "‚úÖ Import scan complete!"

      - name: üìã Terraform Plan
        working-directory: ${{ needs.setup.outputs.tf_dir }}
        run: terraform plan -out=tfplan

      - name: üíæ Upload Plan
        uses: actions/upload-artifact@v4
        with:
          name: tfplan
          path: ${{ needs.setup.outputs.tf_dir }}/tfplan
          retention-days: 5

  apply:
    name: üöÄ Terraform Apply
    runs-on: ubuntu-latest
    needs: [setup, validate, security-scan]
    if: |
      (github.ref == 'refs/heads/main' && github.event_name == 'push') ||
      (github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'apply')
    environment: 
      name: production
    
    steps:
      - name: üì• Checkout Code
        uses: actions/checkout@v4

      - name: üîß Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          terraform_wrapper: false

      - name: üîê Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: üìÇ Create terraform.tfvars
        working-directory: ${{ needs.setup.outputs.tf_dir }}
        run: |
          if [ ! -f terraform.tfvars ]; then
            if [ -f terraform.tfvars.example ]; then
              cp terraform.tfvars.example terraform.tfvars
            else
              cat > terraform.tfvars << 'EOF'
          use_custom_domain = false
          domain_name       = ""
          project_name      = "secure-website"
          environment       = "production"
          allowed_countries = ["US", "CA", "GB"]
          EOF
            fi
          fi

      - name: üîß Terraform Init
        working-directory: ${{ needs.setup.outputs.tf_dir }}
        run: terraform init

      - name: üß† Smart Resource Import & Reconciliation
        working-directory: ${{ needs.setup.outputs.tf_dir }}
        run: |
          echo "üß† Auto-detecting and importing existing resources..."
          
          # Get project config
          PROJECT=$(terraform console <<< "var.project_name" 2>/dev/null | tr -d '"' || echo "secure-website")
          ENV=$(terraform console <<< "var.environment" 2>/dev/null | tr -d '"' || echo "production")
          PREFIX="${PROJECT}-${ENV}"
          
          echo "üìã Configuration:"
          echo "   Project: $PROJECT"
          echo "   Environment: $ENV"
          echo "   Prefix: $PREFIX"
          echo ""
          
          # Smart import function with better error handling
          smart_import() {
            local tf_resource=$1
            local aws_identifier=$2
            local resource_name=$3
            
            # Skip if empty identifier
            if [ -z "$aws_identifier" ] || [ "$aws_identifier" = "null" ]; then
              echo "  ‚ÑπÔ∏è  $resource_name - No existing resource found"
              return 1
            fi
            
            # Check if already in state
            if terraform state show "$tf_resource" &>/dev/null; then
              echo "  ‚úÖ $resource_name - Already in Terraform state"
              return 0
            fi
            
            # Try to import
            echo "  üîÑ $resource_name - Importing from AWS..."
            if terraform import "$tf_resource" "$aws_identifier" 2>&1 | tee /tmp/import_${resource_name// /_}.log; then
              echo "  ‚úÖ $resource_name - Successfully imported!"
              return 0
            else
              if grep -qi "resource not found\|does not exist\|cannot import non-existent" /tmp/import_${resource_name// /_}.log; then
                echo "  ‚ÑπÔ∏è  $resource_name - Will be created"
                return 1
              else
                echo "  ‚ö†Ô∏è  $resource_name - Import returned warnings (may still work)"
                return 1
              fi
            fi
          }
          
          echo "üîç Phase 1: S3 Buckets"
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          smart_import "aws_s3_bucket.website" "${PREFIX}-website" "Website Bucket"
          smart_import "aws_s3_bucket.logs" "${PREFIX}-logs" "Logs Bucket"
          
          echo ""
          echo "üîç Phase 2: WAF Web ACL"
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          
          # Get WAF details
          WAF_JSON=$(aws wafv2 list-web-acls --scope CLOUDFRONT --region us-east-1 --output json 2>/dev/null || echo '{"WebACLs":[]}')
          WAF_ID=$(echo "$WAF_JSON" | jq -r ".WebACLs[] | select(.Name==\"${PREFIX}-waf\") | .Id" 2>/dev/null || echo "")
          WAF_NAME=$(echo "$WAF_JSON" | jq -r ".WebACLs[] | select(.Name==\"${PREFIX}-waf\") | .Name" 2>/dev/null || echo "")
          
          if [ -n "$WAF_ID" ] && [ "$WAF_ID" != "null" ] && [ "$WAF_ID" != "" ]; then
            echo "  Found existing WAF: $WAF_NAME (ID: $WAF_ID)"
            WAF_IMPORT_ID="${WAF_ID}/${WAF_NAME}/CLOUDFRONT"
            smart_import "aws_wafv2_web_acl.main" "$WAF_IMPORT_ID" "WAF Web ACL"
          else
            echo "  ‚ÑπÔ∏è  No existing WAF found - will be created"
          fi
          
          echo ""
          echo "üîç Phase 3: CloudFront Distribution"
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          
          DIST_JSON=$(aws cloudfront list-distributions --output json 2>/dev/null || echo '{"DistributionList":{"Items":[]}}')
          DIST_ID=$(echo "$DIST_JSON" | jq -r ".DistributionList.Items[] | select(.Comment==\"${PREFIX} distribution\") | .Id" 2>/dev/null || echo "")
          
          if [ -n "$DIST_ID" ] && [ "$DIST_ID" != "null" ] && [ "$DIST_ID" != "" ]; then
            echo "  Found existing distribution: $DIST_ID"
            smart_import "aws_cloudfront_distribution.main" "$DIST_ID" "CloudFront Distribution"
            
            # Try to import OAC if it exists
            OAC_ID=$(aws cloudfront list-origin-access-controls --query "OriginAccessControlList.Items[?contains(Name, '${PREFIX}')].Id" --output text 2>/dev/null | head -1 || echo "")
            if [ -n "$OAC_ID" ]; then
              smart_import "aws_cloudfront_origin_access_control.main" "$OAC_ID" "Origin Access Control"
            fi
          else
            echo "  ‚ÑπÔ∏è  No existing CloudFront distribution found - will be created"
          fi
          
          echo ""
          echo "üîç Phase 4: CloudWatch Dashboard"
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          
          if aws cloudwatch get-dashboard --dashboard-name "${PREFIX}-dashboard" --region us-east-1 &>/dev/null; then
            echo "  Found existing dashboard: ${PREFIX}-dashboard"
            smart_import "aws_cloudwatch_dashboard.main" "${PREFIX}-dashboard" "CloudWatch Dashboard"
          else
            echo "  ‚ÑπÔ∏è  No existing dashboard found - will be created"
          fi
          
          echo ""
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          echo "‚úÖ Resource reconciliation complete!"
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          echo ""

      - name: üìã Terraform Plan
        working-directory: ${{ needs.setup.outputs.tf_dir }}
        run: |
          echo "üìã Creating execution plan..."
          terraform plan -out=tfplan
          echo ""
          echo "‚úÖ Plan created successfully"

      - name: üöÄ Terraform Apply
        working-directory: ${{ needs.setup.outputs.tf_dir }}
        run: |
          echo "üöÄ Applying infrastructure changes..."
          terraform apply -auto-approve tfplan
          echo ""
          echo "‚úÖ Infrastructure deployment complete!"

      - name: üì§ Get Outputs
        id: outputs
        working-directory: ${{ needs.setup.outputs.tf_dir }}
        run: |
          echo "website_url=$(terraform output -raw website_url 2>/dev/null || echo 'N/A')" >> $GITHUB_OUTPUT
          echo "cloudfront_domain=$(terraform output -raw cloudfront_domain_name 2>/dev/null || echo 'N/A')" >> $GITHUB_OUTPUT
          echo "s3_bucket=$(terraform output -raw s3_bucket_name 2>/dev/null || echo 'N/A')" >> $GITHUB_OUTPUT
          echo "distribution_id=$(terraform output -raw cloudfront_distribution_id 2>/dev/null || echo 'N/A')" >> $GITHUB_OUTPUT

      - name: üìÅ Upload Website Files
        run: |
          BUCKET="${{ steps.outputs.outputs.s3_bucket }}"
          
          if [ "$BUCKET" = "N/A" ]; then
            echo "‚ö†Ô∏è Bucket not available yet"
            exit 0
          fi
          
          echo "üìÅ Preparing website content..."
          
          # Create default website if needed
          if [ ! -d "website" ]; then
            mkdir -p website
            cat > website/index.html << 'EOF'
          <!DOCTYPE html>
          <html lang="en">
          <head>
              <meta charset="UTF-8">
              <meta name="viewport" content="width=device-width, initial-scale=1.0">
              <title>üöÄ Deployment Successful</title>
              <style>
                  * { margin: 0; padding: 0; box-sizing: border-box; }
                  body {
                      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
                      display: flex;
                      align-items: center;
                      justify-content: center;
                      min-height: 100vh;
                      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                      color: white;
                      padding: 20px;
                  }
                  .container {
                      text-align: center;
                      max-width: 600px;
                      padding: 3rem;
                      background: rgba(255, 255, 255, 0.1);
                      border-radius: 20px;
                      backdrop-filter: blur(10px);
                      box-shadow: 0 8px 32px rgba(0,0,0,0.1);
                  }
                  h1 {
                      font-size: 3rem;
                      margin-bottom: 1rem;
                      text-shadow: 0 2px 10px rgba(0,0,0,0.2);
                  }
                  p { font-size: 1.2rem; opacity: 0.95; margin: 1rem 0; }
                  .badges {
                      display: flex;
                      flex-wrap: wrap;
                      gap: 0.5rem;
                      justify-content: center;
                      margin: 2rem 0;
                  }
                  .badge {
                      padding: 0.5rem 1rem;
                      background: rgba(255, 255, 255, 0.2);
                      border-radius: 25px;
                      font-size: 0.9rem;
                      font-weight: 500;
                  }
                  .footer {
                      margin-top: 2rem;
                      font-size: 0.85rem;
                      opacity: 0.8;
                  }
              </style>
          </head>
          <body>
              <div class="container">
                  <h1>üöÄ</h1>
                  <h1>Deployment Successful!</h1>
                  <p>Your secure AWS infrastructure is now live</p>
                  <div class="badges">
                      <span class="badge">‚úÖ HTTPS Enabled</span>
                      <span class="badge">üõ°Ô∏è WAF Protected</span>
                      <span class="badge">üìä Monitored</span>
                      <span class="badge">‚òÅÔ∏è CloudFront CDN</span>
                      <span class="badge">üîí Secure</span>
                  </div>
                  <p class="footer">
                      Build #${{ github.run_number }} ‚Ä¢ Deployed via GitHub Actions<br>
                      Ready to serve your content globally
                  </p>
              </div>
          </body>
          </html>
          EOF
          fi
          
          # Sync files to S3
          echo "‚òÅÔ∏è Uploading to S3..."
          if [ -d "website" ]; then
            aws s3 sync website/ s3://$BUCKET/ \
              --delete \
              --cache-control "public, max-age=3600" \
              --metadata-directive REPLACE
            echo "‚úÖ Files uploaded successfully"
          fi

      - name: üîÑ Invalidate CloudFront Cache
        run: |
          DIST_ID="${{ steps.outputs.outputs.distribution_id }}"
          if [ "$DIST_ID" != "N/A" ]; then
            echo "üîÑ Invalidating CloudFront cache..."
            aws cloudfront create-invalidation \
              --distribution-id $DIST_ID \
              --paths "/*"
            echo "‚úÖ Cache invalidation initiated"
          fi

      - name: üìä Deployment Summary
        run: |
          cat >> $GITHUB_STEP_SUMMARY << EOF
          ## üöÄ Deployment Complete!
          
          ### üåê Your Website
          **URL:** https://${{ steps.outputs.outputs.cloudfront_domain }}
          
          ### üì¶ Resources
          | Resource | Value |
          |----------|-------|
          | S3 Bucket | \`${{ steps.outputs.outputs.s3_bucket }}\` |
          | CloudFront Distribution | \`${{ steps.outputs.outputs.distribution_id }}\` |
          | CloudFront Domain | \`${{ steps.outputs.outputs.cloudfront_domain }}\` |
          
          ### ‚úÖ Status
          - ‚úÖ Infrastructure deployed/updated
          - ‚úÖ Website files uploaded
          - ‚úÖ Cache invalidated
          - ‚è≥ CloudFront propagation (10-15 minutes)
          
          ### üîó AWS Console Links
          - [CloudFront Distribution](https://console.aws.amazon.com/cloudfront/v3/home#/distributions/${{ steps.outputs.outputs.distribution_id }})
          - [S3 Bucket](https://s3.console.aws.amazon.com/s3/buckets/${{ steps.outputs.outputs.s3_bucket }})
          - [WAF Console](https://console.aws.amazon.com/wafv2/homev2/web-acls?region=global)
          
          ---
          üí° **Note:** First deployment or major changes may take 10-15 minutes to fully propagate
          EOF

  monitor:
    name: üìä Health Check
    runs-on: ubuntu-latest
    needs: [setup, apply]
    if: success()
    
    steps:
      - name: üì• Checkout Code
        uses: actions/checkout@v4

      - name: üîê Configure AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: üîß Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          terraform_wrapper: false

      - name: üîß Init
        working-directory: ${{ needs.setup.outputs.tf_dir }}
        run: terraform init

      - name: üè• Health Check
        working-directory: ${{ needs.setup.outputs.tf_dir }}
        run: |
          echo "## üè• Post-Deployment Health Check" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          DOMAIN=$(terraform output -raw cloudfront_domain_name 2>/dev/null || echo "")
          
          if [ -n "$DOMAIN" ]; then
            URL="https://$DOMAIN"
            echo "üåê Testing: $URL"
            
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" --max-time 10 "$URL" 2>/dev/null || echo "000")
            
            echo "| Check | Status |" >> $GITHUB_STEP_SUMMARY
            echo "|-------|--------|" >> $GITHUB_STEP_SUMMARY
            
            if [ "$HTTP_CODE" = "200" ]; then
              echo "| Website Response | ‚úÖ HTTP $HTTP_CODE - Accessible |" >> $GITHUB_STEP_SUMMARY
            elif [ "$HTTP_CODE" = "000" ]; then
              echo "| Website Response | ‚è≥ Still propagating (wait 10-15 min) |" >> $GITHUB_STEP_SUMMARY
            else
              echo "| Website Response | ‚ö†Ô∏è HTTP $HTTP_CODE - May be propagating |" >> $GITHUB_STEP_SUMMARY
            fi
            
            # Check security headers
            HEADERS=$(curl -sI "$URL" --max-time 10 2>/dev/null || echo "")
            if echo "$HEADERS" | grep -qi "x-amz-cf-id"; then
              echo "| CloudFront | ‚úÖ Serving requests |" >> $GITHUB_STEP_SUMMARY
            fi
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "‚úÖ Deployment workflow completed successfully" >> $GITHUB_STEP_SUMMARY