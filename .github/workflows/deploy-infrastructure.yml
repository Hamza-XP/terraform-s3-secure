name: üöÄ Deploy Infrastructure

on:
  push:
    branches: [main, production]
    paths:
      - '**.tf'
      - '**.tfvars'
      - 'website/**'
      - '.github/workflows/deploy-infrastructure.yml'
  pull_request:
    branches: [main, production]
    paths:
      - '**.tf'
      - '**.tfvars'
  workflow_dispatch:
    inputs:
      action:
        description: 'Action to perform'
        required: true
        default: 'apply'
        type: choice
        options:
          - plan
          - apply

env:
  TF_VERSION: '1.5.0'
  AWS_REGION: 'us-east-1'
  TF_IN_AUTOMATION: true
  TF_INPUT: false
  TF_WORKING_DIR: '.'

permissions:
  contents: read
  pull-requests: write
  security-events: write

jobs:
  setup:
    name: üîç Detect Project Structure
    runs-on: ubuntu-latest
    outputs:
      tf_dir: ${{ steps.detect.outputs.tf_dir }}
    
    steps:
      - name: üì• Checkout Code
        uses: actions/checkout@v4

      - name: üîç Detect Terraform Directory
        id: detect
        run: |
          echo "üîç Detecting Terraform files location..."
          
          if [ -f "main.tf" ]; then
            echo "‚úÖ Found Terraform files in root directory"
            echo "tf_dir=." >> $GITHUB_OUTPUT
          elif [ -f "terraform/main.tf" ]; then
            echo "‚úÖ Found Terraform files in terraform/ subdirectory"
            echo "tf_dir=./terraform" >> $GITHUB_OUTPUT
          else
            echo "‚ùå ERROR: Cannot find main.tf in root or terraform/ directory"
            echo "üìÇ Current directory structure:"
            ls -la
            echo ""
            echo "üìÇ Looking for .tf files:"
            find . -name "*.tf" -type f
            exit 1
          fi

  validate:
    name: üîç Validate Terraform
    runs-on: ubuntu-latest
    needs: setup
    outputs:
      tf-fmt: ${{ steps.fmt.outcome }}
      tf-validate: ${{ steps.validate.outcome }}
    
    steps:
      - name: üì• Checkout Code
        uses: actions/checkout@v4

      - name: üîß Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: üìÇ Show Structure
        run: |
          echo "Working directory: ${{ needs.setup.outputs.tf_dir }}"
          ls -la ${{ needs.setup.outputs.tf_dir }}

      - name: üé® Terraform Format Check
        id: fmt
        working-directory: ${{ needs.setup.outputs.tf_dir }}
        run: terraform fmt -check -recursive
        continue-on-error: true

      - name: üîß Terraform Init
        working-directory: ${{ needs.setup.outputs.tf_dir }}
        run: terraform init -backend=false

      - name: ‚úÖ Terraform Validate
        id: validate
        working-directory: ${{ needs.setup.outputs.tf_dir }}
        run: terraform validate

      - name: üìä Comment PR - Validation
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        continue-on-error: true
        with:
          script: |
            const output = `
            ## üîç Terraform Validation Results
            
            **Working Directory:** \`${{ needs.setup.outputs.tf_dir }}\`
            
            | Check | Result |
            |-------|--------|
            | Format | ${{ steps.fmt.outcome == 'success' && '‚úÖ Passed' || '‚ö†Ô∏è Failed' }} |
            | Validate | ${{ steps.validate.outcome == 'success' && '‚úÖ Passed' || '‚ùå Failed' }} |
            `;
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: output
            });

  security-scan:
    name: üîí Security Scan
    runs-on: ubuntu-latest
    needs: [setup, validate]
    
    steps:
      - name: üì• Checkout Code
        uses: actions/checkout@v4

      - name: üîç Run Checkov
        uses: bridgecrewio/checkov-action@master
        with:
          directory: ${{ needs.setup.outputs.tf_dir }}
          framework: terraform
          soft_fail: true
        continue-on-error: true

  plan:
    name: üìã Terraform Plan
    runs-on: ubuntu-latest
    needs: [setup, validate, security-scan]
    if: github.event_name == 'pull_request' || (github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'plan')
    environment: 
      name: production
    
    steps:
      - name: üì• Checkout Code
        uses: actions/checkout@v4

      - name: üîß Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          terraform_wrapper: false

      - name: üîê Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: üìÇ Create terraform.tfvars
        working-directory: ${{ needs.setup.outputs.tf_dir }}
        run: |
          if [ ! -f terraform.tfvars ]; then
            if [ -f terraform.tfvars.example ]; then
              cp terraform.tfvars.example terraform.tfvars
            else
              cat > terraform.tfvars << 'EOF'
          use_custom_domain = false
          domain_name       = ""
          project_name      = "secure-website"
          environment       = "production"
          allowed_countries = ["US", "CA", "GB"]
          EOF
            fi
          fi

      - name: üîß Terraform Init
        working-directory: ${{ needs.setup.outputs.tf_dir }}
        run: terraform init

      - name: üìã Terraform Plan
        working-directory: ${{ needs.setup.outputs.tf_dir }}
        run: terraform plan -out=tfplan

      - name: üíæ Upload Plan
        uses: actions/upload-artifact@v4
        with:
          name: tfplan
          path: ${{ needs.setup.outputs.tf_dir }}/tfplan
          retention-days: 5

      - name: üìä Comment PR - Plan
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        continue-on-error: true
        with:
          script: |
            const output = `
            ## üìã Terraform Plan Results
            
            ‚úÖ Plan generated successfully
            
            **Next Steps:**
            - Review the plan carefully
            - Merge to \`main\` to apply changes automatically
            - Or use \`workflow_dispatch\` with \`apply\` action
            `;
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: output
            });

  apply:
    name: üöÄ Terraform Apply
    runs-on: ubuntu-latest
    needs: [setup, validate, security-scan]
    if: |
      (github.ref == 'refs/heads/main' && github.event_name == 'push') ||
      (github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'apply')
    environment: 
      name: production
    
    steps:
      - name: üì• Checkout Code
        uses: actions/checkout@v4

      - name: üîß Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          terraform_wrapper: false

      - name: üîê Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: üìÇ Create terraform.tfvars
        working-directory: ${{ needs.setup.outputs.tf_dir }}
        run: |
          if [ ! -f terraform.tfvars ]; then
            if [ -f terraform.tfvars.example ]; then
              cp terraform.tfvars.example terraform.tfvars
            else
              cat > terraform.tfvars << 'EOF'
          use_custom_domain = false
          domain_name       = ""
          project_name      = "secure-website"
          environment       = "production"
          allowed_countries = ["US", "CA", "GB"]
          EOF
            fi
          fi

      - name: üîß Terraform Init
        working-directory: ${{ needs.setup.outputs.tf_dir }}
        run: terraform init

      - name: üßπ Smart Cleanup - Remove Orphaned Resources
        working-directory: ${{ needs.setup.outputs.tf_dir }}
        continue-on-error: true
        run: |
          set +e  # Don't exit on errors during cleanup
          
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          echo "üßπ COMPREHENSIVE CLEANUP - Removing ALL Orphaned Resources"
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          echo ""
          
          # Get target resource names
          PROJECT=$(terraform console <<< "var.project_name" 2>/dev/null | tr -d '"' || echo "secure-website")
          ENV=$(terraform console <<< "var.environment" 2>/dev/null | tr -d '"' || echo "production")
          TARGET_PREFIX="${PROJECT}-${ENV}"
          
          echo "üéØ Target: $TARGET_PREFIX"
          echo ""
          
          # Check if resource is managed
          is_managed() {
            terraform state list 2>/dev/null | grep -q "^$1$"
          }

          # ---------- helper utilities ----------
          log() { echo "[$(date -u +'%Y-%m-%dT%H:%M:%SZ')] $*"; }
          retry() {
            # retry <retries> <sleep> -- command...
            local retries=$1; shift
            local sleep_sec=$1; shift
            local i=0
            until "$@" ; do
              i=$((i+1))
              if [ "$i" -gt "$retries" ]; then
                log "‚ùå Command failed after $retries attempts: $*"
                return 1
              fi
              log "‚è± retry $i/$retries in ${sleep_sec}s..."
              sleep "$sleep_sec"
            done
            return 0
          }
          # wait until CloudFront shows no reference to a given id (poll)
          wait_for_cf_detach() {
            local type="$1"   # "oac" or "rhp"
            local id="$2"
            local timeout=${3:-120}
            local elapsed=0
            local step=5
            while [ "$elapsed" -lt "$timeout" ]; do
              if [ "$type" = "oac" ]; then
                # check origins for the OAC id
                FOUND=$(aws cloudfront list-distributions --output json 2>/dev/null | \
                  jq -r --arg id "$id" '.DistributionList.Items[]? |
                    select((.DistributionConfig.Origins.Items[]?.OriginAccessControlId // "") | contains($id)) | .Id' | head -1)
              else
                # check behaviors for the ResponseHeadersPolicyId OR default cache behavior
                FOUND=$(aws cloudfront list-distributions --output json 2>/dev/null | \
                  jq -r --arg id "$id" '.DistributionList.Items[]? |
                    ( .DistributionConfig.CacheBehaviors.Items[]? | select(.ResponseHeadersPolicyId == $id) | true ) // 
                    ( .DistributionConfig.DefaultCacheBehavior.ResponseHeadersPolicyId == $id ) |
                    select(.) |
                    .Id' | head -1)
              fi

              if [ -z "$FOUND" ]; then
                log "‚úÖ No CloudFront distributions reference $type id=$id"
                return 0
              fi
              log "‚ö†Ô∏è  Still attached to distribution $FOUND; waiting..."
              sleep "$step"
              elapsed=$((elapsed+step))
            done
            log "‚ùå Timeout waiting for detach of $type id=$id"
            return 1
          }

          # ================================================================
          # 1. CLOUDFRONT DISTRIBUTIONS (MUST BE FIRST - REMOVE DEPENDENCIES)
          # ================================================================
          echo "‚òÅÔ∏è  Scanning CloudFront Distributions..."

          aws cloudfront list-distributions --output json 2>/dev/null | \
          jq -r '.DistributionList.Items[]? | "\(.Id)|\(.Comment)|\(.Status)|\(.Enabled)"' | \
          while IFS='|' read -r dist_id comment status enabled; do
            if [[ "$comment" == *"$TARGET_PREFIX"* ]]; then
              if [ "$comment" = "${TARGET_PREFIX} distribution" ] && is_managed "aws_cloudfront_distribution.main"; then
                echo "  ‚úÖ $dist_id - Managed"
              else
                echo "  üóëÔ∏è  Orphaned: $dist_id ($comment)"
                if [ "$enabled" = "true" ]; then
                  echo "     Disabling..."
                  aws cloudfront get-distribution-config --id "$dist_id" > /tmp/cf_$dist_id.json 2>/dev/null
                  ETAG=$(jq -r '.ETag' /tmp/cf_$dist_id.json)
                  jq '.DistributionConfig.Enabled = false' /tmp/cf_$dist_id.json > /tmp/cf_disabled_$dist_id.json
                  aws cloudfront update-distribution \
                    --id "$dist_id" \
                    --if-match "$ETAG" \
                    --distribution-config "$(jq -c '.DistributionConfig' /tmp/cf_disabled_$dist_id.json)" \
                    2>/dev/null && echo "     ‚úÖ Disabled" || echo "     ‚ö†Ô∏è  Failed to disable"
                fi
                
                # DELETE the distribution
                echo "     Deleting distribution..."
                ETAG=$(aws cloudfront get-distribution --id "$dist_id" --query 'ETag' --output text 2>/dev/null)
                if [ -n "$ETAG" ]; then
                  aws cloudfront delete-distribution --id "$dist_id" --if-match "$ETAG" 2>&1 && \
                  echo "     ‚úÖ Deleted distribution" || echo "     ‚ö†Ô∏è  Distribution deletion in progress"
                fi
              fi
            fi
          done

          # Wait for distributions to be removed
          echo "     Waiting for CloudFront distributions to be removed..."
          sleep 30

          # ---------- CLOUD FRONT ORIGIN ACCESS CONTROLS ----------
          log "üîí Scanning CloudFront Origin Access Controls..."

          aws cloudfront list-origin-access-controls --output json 2>/dev/null | \
          jq -r '.OriginAccessControlList.Items[]? | "\(.Id)|\(.Name)"' | \
          while IFS='|' read -r oac_id oac_name; do
            if [[ "$oac_name" == *"$TARGET_PREFIX"* ]]; then
              if is_managed "aws_cloudfront_origin_access_control.website"; then
                log "  ‚úÖ $oac_name - Managed by Terraform"
              else
                log "  üóëÔ∏è  Orphaned OAC: $oac_name ($oac_id)"
                # Try to import into terraform first
                if terraform state show aws_cloudfront_origin_access_control.website &>/dev/null; then
                  log "     Already in tfstate: aws_cloudfront_origin_access_control.website"
                else
                  log "     Attempting terraform import..."
                  if terraform import -lock=false aws_cloudfront_origin_access_control.website "$oac_id" 2>&1 | tee /tmp/import_oac.log; then
                    log "     ‚úÖ Imported OAC into terraform"
                    continue
                  else
                    log "     ‚ö†Ô∏è  Import failed - will attempt safe detach & delete"
                    # Find distributions referencing this OAC and remove the origin AccessControlId
                    DIST_IDS=$(aws cloudfront list-distributions --output json 2>/dev/null | \
                      jq -r --arg id "$oac_id" '.DistributionList.Items[]? |
                        select((.DistributionConfig.Origins.Items[]?.OriginAccessControlId // "") | contains($id)) | .Id')
                    
                    for dist in $DIST_IDS; do
                      log "     üîÑ Updating distribution $dist to remove OAC reference..."
                      aws cloudfront get-distribution-config --id "$dist" > /tmp/dist_cfg_$dist.json
                      ETAG=$(jq -r '.ETag' /tmp/dist_cfg_$dist.json)
                      # remove OriginAccessControlId in all origins that match
                      jq --arg id "$oac_id" '.DistributionConfig.Origins.Items |= map(
                           if .OriginAccessControlId == $id then .OriginAccessControlId = "" else . end
                         )' /tmp/dist_cfg_$dist.json > /tmp/dist_cfg_no_oac_$dist.json
                      retry 3 5 aws cloudfront update-distribution --id "$dist" --if-match "$ETAG" --distribution-config "$(jq -c '.DistributionConfig' /tmp/dist_cfg_no_oac_$dist.json)" || log "     ‚ö†Ô∏è  update-distribution failed for $dist"
                    done

                    # wait until no dist references OAC
                    wait_for_cf_detach "oac" "$oac_id" 180 || log "     ‚ö†Ô∏è  Some distributions still reference OAC $oac_id"

                    # re-get etag and attempt delete (delete requires If-Match header but get-origin-access-control returns ETag)
                    ETAG=$(aws cloudfront get-origin-access-control --id "$oac_id" --query 'ETag' --output text 2>/dev/null)
                    if [ -n "$ETAG" ]; then
                      if aws cloudfront delete-origin-access-control --id "$oac_id" --if-match "$ETAG" 2>/dev/null; then
                        log "     ‚úÖ Deleted OAC $oac_name"
                      else
                        log "     ‚ö†Ô∏è  Failed to delete OAC $oac_name (maybe still attached or IAM issue)"
                      fi
                    else
                      log "     ‚ùå Could not fetch ETag for OAC $oac_id; skipping deletion"
                    fi
                  fi
                fi
              fi
            fi
          done

          # ---------- CLOUD FRONT RESPONSE HEADERS POLICIES ----------
          log "üìã Scanning CloudFront Response Headers Policies..."
          aws cloudfront list-response-headers-policies --type custom --output json 2>/dev/null | \
          jq -r '.ResponseHeadersPolicyList.Items[]? | "\(.ResponseHeadersPolicy.Id)|\(.ResponseHeadersPolicy.ResponseHeadersPolicyConfig.Name)"' | \
          while IFS='|' read -r policy_id policy_name; do
            if [[ "$policy_name" == *"$TARGET_PREFIX"* ]]; then
              if is_managed "aws_cloudfront_response_headers_policy.security_headers"; then
                log "  ‚úÖ $policy_name - Managed by Terraform"
              else
                log "  üóëÔ∏è  Orphaned RHP: $policy_name ($policy_id)"
                # Try to import first
                if terraform state show aws_cloudfront_response_headers_policy.security_headers &>/dev/null; then
                  log "     Already in tfstate: aws_cloudfront_response_headers_policy.security_headers"
                else
                  log "     Attempting terraform import..."
                  if terraform import -lock=false aws_cloudfront_response_headers_policy.security_headers "$policy_id" 2>&1 | tee /tmp/import_rhp.log; then
                    log "     ‚úÖ Imported Response Headers Policy into terraform"
                    continue
                  else
                    log "     ‚ö†Ô∏è  Import failed - will attempt to detach from cache behaviors and delete"
                    # iterate distributions and remove any ResponseHeadersPolicyId references in default and cache behaviors
                    DIST_IDS=$(aws cloudfront list-distributions --output json 2>/dev/null | \
                      jq -r --arg pid "$policy_id" '.DistributionList.Items[]? |
                        select((.DistributionConfig.DefaultCacheBehavior.ResponseHeadersPolicyId == $pid) or
                               (.DistributionConfig.CacheBehaviors.Items[]? | select(.ResponseHeadersPolicyId == $pid) | . == .)) | .Id' | sort -u)
                    
                    for dist in $DIST_IDS; do
                      log "     üîÑ Updating distribution $dist to remove ResponseHeadersPolicy $policy_id..."
                      aws cloudfront get-distribution-config --id "$dist" > /tmp/dist_rhp_$dist.json
                      ETAG=$(jq -r '.ETag' /tmp/dist_rhp_$dist.json)
                      # remove from default cache behavior
                      jq --arg pid "$policy_id" '
                        .DistributionConfig |
                        (if .DefaultCacheBehavior.ResponseHeadersPolicyId == $pid then .DefaultCacheBehavior.ResponseHeadersPolicyId = "" else . end) |
                        (.CacheBehaviors.Items |= map(if .ResponseHeadersPolicyId == $pid then .ResponseHeadersPolicyId = "" else . end))
                      ' /tmp/dist_rhp_$dist.json > /tmp/dist_rhp_no_pid_$dist.json

                      retry 3 5 aws cloudfront update-distribution --id "$dist" --if-match "$ETAG" --distribution-config "$(jq -c '.DistributionConfig' /tmp/dist_rhp_no_pid_$dist.json)" || log "     ‚ö†Ô∏è  update-distribution failed for $dist"
                    done

                    wait_for_cf_detach "rhp" "$policy_id" 180 || log "     ‚ö†Ô∏è  Some distributions still reference RHP $policy_id"

                    # now try delete
                    ETAG=$(aws cloudfront get-response-headers-policy --id "$policy_id" --query 'ETag' --output text 2>/dev/null)
                    if [ -n "$ETAG" ]; then
                      if aws cloudfront delete-response-headers-policy --id "$policy_id" --if-match "$ETAG" 2>/dev/null; then
                        log "     ‚úÖ Deleted Response Headers Policy $policy_name"
                      else
                        log "     ‚ö†Ô∏è  Failed to delete Response Headers Policy $policy_name (might still be attached)"
                      fi
                    else
                      log "     ‚ùå Could not get ETag for Response Headers Policy $policy_id"
                    fi
                  fi
                fi
              fi
            fi
          done

          # ================================================================
          # 2. WAF WEB ACLs (NOW CAN BE DELETED SINCE CLOUDFRONT IS GONE)
          # ================================================================
          echo ""
          echo "üõ°Ô∏è  Scanning WAF Web ACLs..."

          aws wafv2 list-web-acls --scope CLOUDFRONT --region us-east-1 --output json 2>/dev/null | \
          jq -r '.WebACLs[]? | "\(.Id)|\(.Name)|\(.LockToken)"' | \
          while IFS='|' read -r waf_id waf_name lock_token; do
            if [[ "$waf_name" == *"$TARGET_PREFIX"* ]]; then
              if [ "$waf_name" = "${TARGET_PREFIX}-waf" ] && is_managed "aws_wafv2_web_acl.website"; then
                echo "  ‚úÖ $waf_name - Managed"
              else
                echo "  üóëÔ∏è  Orphaned: $waf_name"
                # Now it should be deletable since CloudFront distributions are gone
                aws wafv2 delete-web-acl --name "$waf_name" --scope CLOUDFRONT --id "$waf_id" --lock-token "$lock_token" --region us-east-1
                echo "     ‚úÖ Deleted" || echo "     ‚ö†Ô∏è  Failed to delete"
              fi
            fi
          done
          
          # ================================================================
          # 3. CLOUDWATCH LOG GROUPS
          # ================================================================
          echo ""
          echo "üìù Scanning CloudWatch Log Groups..."
          
          aws logs describe-log-groups --output json 2>/dev/null | \
          jq -r '.logGroups[]? | .logGroupName' | grep "$TARGET_PREFIX" | \
          while read -r log_group; do
            if is_managed "aws_cloudwatch_log_group.waf_logs"; then
              echo "  ‚úÖ $log_group - Managed"
            else
              echo "  üóëÔ∏è  Orphaned: $log_group"
              aws logs delete-log-group --log-group-name "$log_group" 2>&1 && \
              echo "     ‚úÖ Deleted" || echo "     ‚ö†Ô∏è  Failed"
            fi
          done
          
          # ================================================================
          # 4. KINESIS FIREHOSE DELIVERY STREAMS
          # ================================================================
          echo ""
          echo "üî• Scanning Kinesis Firehose Delivery Streams..."
          
          aws firehose list-delivery-streams --output json 2>/dev/null | \
          jq -r '.DeliveryStreamNames[]?' | grep "$TARGET_PREFIX" | \
          while read -r stream; do
            if is_managed "aws_kinesis_firehose_delivery_stream.waf_logs"; then
              echo "  ‚úÖ $stream - Managed"
            else
              echo "  üóëÔ∏è  Orphaned: $stream"
              aws firehose delete-delivery-stream --delivery-stream-name "$stream" 2>&1 && \
              echo "     ‚úÖ Deleted" || echo "     ‚ö†Ô∏è  Failed"
            fi
          done
          
          # ================================================================
          # 5. IAM ROLES (with policy cleanup)
          # ================================================================
          echo ""
          echo "üë§ Scanning IAM Roles..."
          
          aws iam list-roles --output json 2>/dev/null | \
          jq -r '.Roles[]? | .RoleName' | grep "$TARGET_PREFIX" | \
          while read -r role; do
            if is_managed "aws_iam_role.firehose_delivery_role"; then
              echo "  ‚úÖ $role - Managed"
            else
              echo "  üóëÔ∏è  Orphaned: $role"
              
              # Detach inline policies
              aws iam list-role-policies --role-name "$role" --output json 2>/dev/null | \
              jq -r '.PolicyNames[]?' | \
              while read -r policy; do
                aws iam delete-role-policy --role-name "$role" --policy-name "$policy" 2>/dev/null
              done
              
              # Detach managed policies
              aws iam list-attached-role-policies --role-name "$role" --output json 2>/dev/null | \
              jq -r '.AttachedPolicies[]?.PolicyArn' | \
              while read -r policy_arn; do
                aws iam detach-role-policy --role-name "$role" --policy-arn "$policy_arn" 2>/dev/null
              done
              
              # Delete role
              aws iam delete-role --role-name "$role" 2>&1 && \
              echo "     ‚úÖ Deleted" || echo "     ‚ö†Ô∏è  Failed"
            fi
          done
          
          # ================================================================
          # 6. S3 BUCKETS (enhanced emptying)
          # ================================================================
          echo ""
          echo "üì¶ Scanning S3 Buckets..."

          aws s3api list-buckets --output json 2>/dev/null | \
          jq -r '.Buckets[]? | .Name' | grep "$TARGET_PREFIX" | \
          while read -r bucket; do
            SKIP=false
            if [ "$bucket" = "${TARGET_PREFIX}-website" ] && is_managed "aws_s3_bucket.website"; then
              echo "  ‚úÖ $bucket - Managed (website)"
              SKIP=true
            fi
            if [ "$bucket" = "${TARGET_PREFIX}-logs" ] && is_managed "aws_s3_bucket.logs"; then
              echo "  ‚úÖ $bucket - Managed (logs)"
              SKIP=true
            fi
            
            if [ "$SKIP" = "false" ]; then
              echo "  üóëÔ∏è  Orphaned: $bucket"
              echo "     Emptying completely..."
              
              # Delete all versions and markers
              aws s3api list-object-versions --bucket "$bucket" --output json 2>/dev/null | \
              jq -r '.Versions[]?, .DeleteMarkers[]? | "\(.Key)\t\(.VersionId)"' | \
              while IFS=$'\t' read -r key version_id; do
                if [ -n "$key" ]; then
                  if [ "$version_id" = "null" ]; then
                    aws s3api delete-object --bucket "$bucket" --key "$key" 2>/dev/null
                  else
                    aws s3api delete-object --bucket "$bucket" --key "$key" --version-id "$version_id" 2>/dev/null
                  fi
                fi
              done

              # Then delete the bucket
              aws s3api delete-bucket --bucket "$bucket" 2>&1 && \
              echo "     ‚úÖ Deleted" || echo "     ‚ö†Ô∏è  Failed"
            fi
          done

          # ================================================================
          # 7. CLOUDWATCH ALARMS
          # ================================================================
          echo ""
          echo "üö® Scanning CloudWatch Alarms..."

          aws cloudwatch describe-alarms --output json 2>/dev/null | \
          jq -r '.MetricAlarms[]? | .AlarmName' | grep "$TARGET_PREFIX" | \
          while read -r alarm; do
            echo "  üóëÔ∏è  Orphaned: $alarm"
            aws cloudwatch delete-alarms --alarm-names "$alarm" 2>&1 && \
            echo "     ‚úÖ Deleted" || echo "     ‚ö†Ô∏è  Failed"
          done

      - name: üîç Detect WAF Resource Name
        id: detect_waf
        working-directory: ${{ needs.setup.outputs.tf_dir }}
        run: |
          if grep -r "resource \"aws_wafv2_web_acl\" \"website\"" . >/dev/null 2>&1; then
            echo "waf_resource=aws_wafv2_web_acl.website" >> $GITHUB_OUTPUT
            echo "‚úÖ Detected: aws_wafv2_web_acl.website"
          elif grep -r "resource \"aws_wafv2_web_acl\" \"main\"" . >/dev/null 2>&1; then
            echo "waf_resource=aws_wafv2_web_acl.main" >> $GITHUB_OUTPUT
            echo "‚úÖ Detected: aws_wafv2_web_acl.main"
          else
            echo "waf_resource=aws_wafv2_web_acl.website" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è  Using default: aws_wafv2_web_acl.website"
          fi

      - name: üß† Smart Resource Import
        working-directory: ${{ needs.setup.outputs.tf_dir }}
        env:
          WAF_RESOURCE: ${{ steps.detect_waf.outputs.waf_resource }}
        run: |
          set +e  # Don't exit on import errors
          
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          echo "üß† SMART RESOURCE IMPORT - Reuse Existing Resources"
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          echo ""
          
          PROJECT=$(terraform console <<< "var.project_name" 2>/dev/null | tr -d '"' || echo "secure-website")
          ENV=$(terraform console <<< "var.environment" 2>/dev/null | tr -d '"' || echo "production")
          PREFIX="${PROJECT}-${ENV}"
          
          echo "üìã Configuration:"
          echo "   Project: $PROJECT"
          echo "   Environment: $ENV"
          echo "   Prefix: $PREFIX"
          echo "   WAF Resource: $WAF_RESOURCE"
          echo ""
          
          # Smart import function
          smart_import() {
            local tf_resource=$1
            local aws_id=$2
            local name=$3
            
            if [ -z "$aws_id" ] || [ "$aws_id" = "null" ]; then
              echo "  ‚ÑπÔ∏è  $name - Not found in AWS (will be created)"
              return 1
            fi
            
            if terraform state show "$tf_resource" &>/dev/null; then
              echo "  ‚úÖ $name - Already managed"
              return 0
            fi
            
            echo "  üîÑ $name - Importing..."
            if terraform import "$tf_resource" "$aws_id" 2>&1 | tee /tmp/import_$name.log; then
              echo "  ‚úÖ $name - Imported successfully!"
              return 0
            else
              if grep -qi "already exists\|duplicate" /tmp/import_$name.log; then
                echo "  ‚ö†Ô∏è  $name - Exists but cannot import (will handle automatically)"
              else
                echo "  ‚ÑπÔ∏è  $name - Will be created"
              fi
              return 1
            fi
          }
          
          # Import S3 Buckets
          echo "üì¶ S3 Buckets:"
          smart_import "aws_s3_bucket.website" "${PREFIX}-website" "Website Bucket"
          smart_import "aws_s3_bucket.logs" "${PREFIX}-logs" "Logs Bucket"
          
          # Import WAF with automatic duplicate handling
          echo ""
          echo "üõ°Ô∏è  WAF Web ACL:"
          WAF_JSON=$(aws wafv2 list-web-acls --scope CLOUDFRONT --region us-east-1 --output json 2>/dev/null || echo '{"WebACLs":[]}')
          WAF_ID=$(echo "$WAF_JSON" | jq -r ".WebACLs[] | select(.Name==\"${PREFIX}-waf\") | .Id" 2>/dev/null)

          if [ -n "$WAF_ID" ] && [ "$WAF_ID" != "null" ]; then
            WAF_IMPORT_ID="${WAF_ID}/${PREFIX}-waf/CLOUDFRONT"
            
            if ! smart_import "$WAF_RESOURCE" "$WAF_IMPORT_ID" "WAF Web ACL"; then
              # Import failed - delete and recreate
              echo "  üîÑ Import failed - removing duplicate WAF..."
              LOCK_TOKEN=$(echo "$WAF_JSON" | jq -r ".WebACLs[] | select(.Name==\"${PREFIX}-waf\") | .LockToken")
              
              if [ -n "$LOCK_TOKEN" ]; then
                # Check if attached to CloudFront
                ATTACHED=$(aws cloudfront list-distributions --output json 2>/dev/null | \
                          jq -r ".DistributionList.Items[]? | select(.WebACLId | contains(\"$WAF_ID\")) | .Id" | head -1)
                
                if [ -n "$ATTACHED" ]; then
                  echo "  üîÑ Detaching from CloudFront $ATTACHED..."
                  aws cloudfront get-distribution-config --id "$ATTACHED" > /tmp/dist_waf.json
                  DIST_ETAG=$(cat /tmp/dist_waf.json | jq -r '.ETag')
                  
                  cat /tmp/dist_waf.json | jq '.DistributionConfig.WebACLId = ""' > /tmp/dist_no_waf.json
                  
                  aws cloudfront update-distribution \
                    --id "$ATTACHED" \
                    --if-match "$DIST_ETAG" \
                    --distribution-config "$(cat /tmp/dist_no_waf.json | jq -c '.DistributionConfig')" 2>/dev/null || true
                  
                  sleep 5
                fi
                
                echo "  üóëÔ∏è  Deleting duplicate WAF..."
                aws wafv2 delete-web-acl \
                  --name "${PREFIX}-waf" \
                  --scope CLOUDFRONT \
                  --id "$WAF_ID" \
                  --lock-token "$LOCK_TOKEN" \
                  --region us-east-1 2>&1 && \
                echo "  ‚úÖ Deleted - Terraform will create new one" || \
                echo "  ‚ö†Ô∏è  Could not delete"
              fi
            fi
          else
            echo "  ‚ÑπÔ∏è  WAF not found (will be created)"
          fi

          # Import CloudFront
          echo ""
          echo "‚òÅÔ∏è  CloudFront Distribution:"
          DIST_JSON=$(aws cloudfront list-distributions --output json 2>/dev/null || echo '{"DistributionList":{"Items":[]}}')
          DIST_ID=$(echo "$DIST_JSON" | jq -r ".DistributionList.Items[] | select(.Comment==\"${PREFIX} distribution\") | .Id" 2>/dev/null)
          smart_import "aws_cloudfront_distribution.main" "$DIST_ID" "CloudFront Distribution"

          # Import Response Headers Policy if exists
          echo "üìã Checking for existing Response Headers Policy (${PREFIX}-security-headers)"
          RHP_ID=$(aws cloudfront list-response-headers-policies --type custom --output json 2>/dev/null | \
            jq -r --arg name "${PREFIX}-security-headers" '.ResponseHeadersPolicyList.Items[]? |
              select(.ResponseHeadersPolicy.ResponseHeadersPolicyConfig.Name == $name) | .ResponseHeadersPolicy.Id' | head -1)

          if [ -n "$RHP_ID" ]; then
            echo "  Found Response Headers Policy id=$RHP_ID, attempting import..."
            if ! smart_import "aws_cloudfront_response_headers_policy.security_headers" "$RHP_ID" "Response Headers Policy"; then
              echo "  Import failed. The cleanup step will attempt to detach and delete it so Terraform can recreate it."
            fi
          else
            echo "  No existing Response Headers Policy named ${PREFIX}-security-headers found"
          fi

          # Import OAC if exists
          echo "üîí Checking for existing Origin Access Control (${PREFIX}-oac)"
          OAC_ID=$(aws cloudfront list-origin-access-controls --output json 2>/dev/null | \
            jq -r --arg name "${PREFIX}-oac" '.OriginAccessControlList.Items[]? | select(.Name==$name) | .Id' | head -1)

          if [ -n "$OAC_ID" ]; then
            echo "  Found OAC id=$OAC_ID, attempting import..."
            if ! smart_import "aws_cloudfront_origin_access_control.website" "$OAC_ID" "Origin Access Control"; then
              echo "  Import failed. The cleanup step will attempt to detach and delete it so Terraform can recreate it."
            fi
          else
            echo "  No existing OAC named ${PREFIX}-oac found"
          fi
          
          # Import CloudWatch Dashboard
          echo ""
          echo "üìä CloudWatch Dashboard:"
          if aws cloudwatch get-dashboard --dashboard-name "${PREFIX}-dashboard" --region us-east-1 &>/dev/null; then
            smart_import "aws_cloudwatch_dashboard.main" "${PREFIX}-dashboard" "Dashboard"
          else
            echo "  ‚ÑπÔ∏è  Dashboard not found (will be created)"
          fi
          
          echo ""
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          echo "‚úÖ Import process complete!"
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          echo ""
          
          set -e

      - name: üìã Terraform Plan
        working-directory: ${{ needs.setup.outputs.tf_dir }}
        run: |
          echo "üìã Creating execution plan..."
          terraform plan -out=tfplan

      - name: üöÄ Terraform Apply
        working-directory: ${{ needs.setup.outputs.tf_dir }}
        run: |
          echo "üöÄ Applying infrastructure changes..."
          terraform apply -auto-approve tfplan

      - name: üì§ Get Outputs
        id: outputs
        working-directory: ${{ needs.setup.outputs.tf_dir }}
        run: |
          echo "website_url=$(terraform output -raw website_url 2>/dev/null || echo 'N/A')" >> $GITHUB_OUTPUT
          echo "cloudfront_domain=$(terraform output -raw cloudfront_domain_name 2>/dev/null || echo 'N/A')" >> $GITHUB_OUTPUT
          echo "s3_bucket=$(terraform output -raw s3_bucket_name 2>/dev/null || echo 'N/A')" >> $GITHUB_OUTPUT
          echo "distribution_id=$(terraform output -raw cloudfront_distribution_id 2>/dev/null || echo 'N/A')" >> $GITHUB_OUTPUT

      - name: üìÅ Upload Website Files
        run: |
          BUCKET="${{ steps.outputs.outputs.s3_bucket }}"
          
          if [ "$BUCKET" = "N/A" ]; then
            echo "‚ö†Ô∏è Bucket not available"
            exit 0
          fi
          
          # Create default website if needed
          if [ ! -d "website" ]; then
            mkdir -p website
            cat > website/index.html << 'EOF'
          <!DOCTYPE html>
          <html>
          <head>
              <meta charset="UTF-8">
              <meta name="viewport" content="width=device-width, initial-scale=1.0">
              <title>Deployed!</title>
              <style>
                  body {
                      font-family: system-ui, -apple-system, sans-serif;
                      display: flex;
                      align-items: center;
                      justify-content: center;
                      min-height: 100vh;
                      margin: 0;
                      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                      color: white;
                  }
                  .card {
                      text-align: center;
                      padding: 3rem;
                      background: rgba(255, 255, 255, 0.1);
                      border-radius: 15px;
                      backdrop-filter: blur(10px);
                      box-shadow: 0 8px 32px rgba(0,0,0,0.1);
                  }
                  h1 { margin: 0 0 1rem; font-size: 2.5rem; }
                  p { margin: 0.5rem 0; opacity: 0.9; }
                  .badges { margin: 2rem 0; }
                  .badge {
                      display: inline-block;
                      padding: 0.5rem 1rem;
                      margin: 0.25rem;
                      background: rgba(255, 255, 255, 0.2);
                      border-radius: 20px;
                      font-size: 0.9rem;
                  }
              </style>
          </head>
          <body>
              <div class="card">
                  <h1>üöÄ Website Deployed!</h1>
                  <p>Your secure infrastructure is live</p>
                  <div class="badges">
                      <span class="badge">‚úÖ HTTPS</span>
                      <span class="badge">üõ°Ô∏è WAF Protected</span>
                      <span class="badge">üìä Monitored</span>
                      <span class="badge">‚òÅÔ∏è CloudFront</span>
                  </div>
                  <p style="font-size: 0.85rem; margin-top: 2rem;">
                      Build #${{ github.run_number }} ‚Ä¢ GitHub Actions
                  </p>
              </div>
          </body>
          </html>
          EOF
          fi
          
          # Sync all files to S3
          echo "üìÅ Syncing website files to S3..."
          if [ -d "website" ]; then
            aws s3 sync website/ s3://$BUCKET/ \
              --delete \
              --exclude ".*" \
              --cache-control "public, max-age=3600" \
              --metadata-directive REPLACE
            echo "‚úÖ Files synced successfully"
          fi

      - name: üîÑ Invalidate CloudFront Cache
        run: |
          DIST_ID="${{ steps.outputs.outputs.distribution_id }}"
          if [ "$DIST_ID" != "N/A" ]; then
            echo "üîÑ Invalidating CloudFront cache..."
            aws cloudfront create-invalidation \
              --distribution-id $DIST_ID \
              --paths "/*"
            echo "‚úÖ Cache invalidation created"
          fi

      - name: üìä Deployment Summary
        run: |
          echo "## üöÄ Deployment Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üåê Your Website" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**URL:** https://${{ steps.outputs.outputs.cloudfront_domain }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üì¶ Resources" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Resource | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| S3 Bucket | \`${{ steps.outputs.outputs.s3_bucket }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Distribution ID | \`${{ steps.outputs.outputs.distribution_id }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| CloudFront Domain | \`${{ steps.outputs.outputs.cloudfront_domain }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "üí° **Note:** CloudFront propagation takes 10-15 minutes" >> $GITHUB_STEP_SUMMARY

  monitor:
    name: üìä Post-Deployment Monitoring
    runs-on: ubuntu-latest
    needs: [setup, apply]
    if: success()
    
    steps:
      - name: üì• Checkout Code
        uses: actions/checkout@v4

      - name: üîê Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: üîß Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          terraform_wrapper: false

      - name: üîß Terraform Init
        working-directory: ${{ needs.setup.outputs.tf_dir }}
        run: terraform init

      - name: üìä Enhanced Deployment Verification
        working-directory: ${{ needs.setup.outputs.tf_dir }}
        run: |
          echo "## üìä Deployment Verification" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          DIST=$(terraform output -raw cloudfront_distribution_id 2>/dev/null || echo "N/A")
          DOMAIN=$(terraform output -raw cloudfront_domain_name 2>/dev/null || echo "N/A")
          BUCKET=$(terraform output -raw s3_bucket_name 2>/dev/null || echo "N/A")
          WAF=$(terraform output -raw waf_web_acl_arn 2>/dev/null || echo "N/A")
          DASHBOARD=$(terraform output -raw dashboard_url 2>/dev/null || echo "N/A")
          
          echo "### ‚úÖ Resources Status" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Resource | Status | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|--------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| ‚òÅÔ∏è CloudFront | ‚úÖ Active | $DIST |" >> $GITHUB_STEP_SUMMARY
          echo "| üì¶ S3 Bucket | ‚úÖ Active | $BUCKET |" >> $GITHUB_STEP_SUMMARY
          echo "| üõ°Ô∏è WAF ACL | ‚úÖ Active | $(echo $WAF | cut -d'/' -f2-) |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          echo "### üß™ Health Checks" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Check | Result | Details |" >> $GITHUB_STEP_SUMMARY
          echo "|-------|--------|---------|" >> $GITHUB_STEP_SUMMARY
          
          if [ "$DOMAIN" != "N/A" ]; then
            URL="https://$DOMAIN"
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" --max-time 10 "$URL" 2>/dev/null || echo "000")
            
            if [ "$HTTP_CODE" = "200" ]; then
              echo "| üåê Website Access | ‚úÖ Success | HTTP $HTTP_CODE |" >> $GITHUB_STEP_SUMMARY
            elif [ "$HTTP_CODE" = "000" ]; then
              echo "| üåê Website Access | ‚è≥ Propagating | Wait 5-10 minutes |" >> $GITHUB_STEP_SUMMARY
            else
              echo "| üåê Website Access | ‚ö†Ô∏è HTTP $HTTP_CODE | May be propagating |" >> $GITHUB_STEP_SUMMARY
            fi
            
            HEADERS=$(curl -sI "$URL" --max-time 10 2>/dev/null || echo "")
            if echo "$HEADERS" | grep -qi "x-amz-cf-id"; then
              echo "| ‚òÅÔ∏è CloudFront | ‚úÖ Serving | Requests via CDN |" >> $GITHUB_STEP_SUMMARY
            fi
            
            if echo "$HEADERS" | grep -qi "strict-transport-security"; then
              echo "| üîí Security Headers | ‚úÖ Configured | HSTS enabled |" >> $GITHUB_STEP_SUMMARY
            else
              echo "| üîí Security Headers | ‚è≥ Propagating | Will appear shortly |" >> $GITHUB_STEP_SUMMARY
            fi
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üìà Monitoring & Management" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Service | Console Link |" >> $GITHUB_STEP_SUMMARY
          echo "|---------|--------------|" >> $GITHUB_STEP_SUMMARY
          echo "| ‚òÅÔ∏è CloudFront | [View Distribution](https://console.aws.amazon.com/cloudfront/v3/home#/distributions/$DIST) |" >> $GITHUB_STEP_SUMMARY
          echo "| üì¶ S3 Bucket | [View Bucket](https://s3.console.aws.amazon.com/s3/buckets/$BUCKET) |" >> $GITHUB_STEP_SUMMARY
          
          if [ "$DASHBOARD" != "N/A" ]; then
            echo "| üìä CloudWatch | [View Dashboard]($DASHBOARD) |" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "| üõ°Ô∏è WAF & Shield | [View Web ACLs](https://console.aws.amazon.com/wafv2/homev2/web-acls?region=global) |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üåê Your Website" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**üéâ Access your website at:** https://$DOMAIN" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "üí° **Note:** CloudFront can take 10-15 minutes to fully propagate worldwide." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ‚úÖ Next Steps" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ Infrastructure deployed/updated successfully" >> $GITHUB_STEP_SUMMARY
          echo "- üåê Test your website using the CloudFront URL above" >> $GITHUB_STEP_SUMMARY
          echo "- üìä Monitor performance via CloudWatch dashboard" >> $GITHUB_STEP_SUMMARY
          echo "- üõ°Ô∏è Review security settings in WAF console" >> $GITHUB_STEP_SUMMARY
          echo "- üìÅ Upload custom content to the S3 bucket" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üîÑ Resource Management" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- üßπ Orphaned resources automatically cleaned" >> $GITHUB_STEP_SUMMARY
          echo "- üîÑ Existing resources imported and reused" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ Same CloudFront URL on every deployment" >> $GITHUB_STEP_SUMMARY
          echo "- üí∞ No duplicate resources wasting costs" >> $GITHUB_STEP_SUMMARY